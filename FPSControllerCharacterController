using UnityEngine;
using UnityEngine.InputSystem;

public class FPSCharacterController : MonoBehaviour
{
    //this is fps controller using the character controller instead of the rigidbody i actully prefer this!
    [Header("Movement Settings")]
    public float moveSpeed = 5f; // Speed of player movement
    public float jumpHeight = 2f; // Height of the player's jump
    public float gravity = -9.81f; // Gravity applied to the player

    [Header("Mouse Settings")]
    public float mouseSensitivity = 100f; // Sensitivity of the mouse for looking around

    private CharacterController characterController; // Reference to the CharacterController component
    private PlayerInputActions inputActions; // Reference to the generated Input Actions class
    private Vector2 moveInput; // Stores movement input from the player
    private Vector2 lookInput; // Stores look input from the player
    private Vector3 velocity; // Tracks the player's velocity
    private bool isGrounded; // Tracks whether the player is on the ground

    private float xRotation = 0f; // Tracks the vertical rotation of the camera

    private void Awake()
    {
        characterController = GetComponent<CharacterController>(); // Get the CharacterController component

        // Initialize the Input Actions
        inputActions = new PlayerInputActions();

        // Subscribe to the Move action
        inputActions.Player.Move.performed += ctx => moveInput = ctx.ReadValue<Vector2>(); // Update moveInput when movement is performed
        inputActions.Player.Move.canceled += ctx => moveInput = Vector2.zero; // Reset moveInput when movement is canceled

        // Subscribe to the Look action
        inputActions.Player.Look.performed += ctx => lookInput = ctx.ReadValue<Vector2>(); // Update lookInput when looking around
        inputActions.Player.Look.canceled += ctx => lookInput = Vector2.zero; // Reset lookInput when looking stops

        // Subscribe to the Jump action
        inputActions.Player.Jump.performed += ctx => Jump(); // Call the Jump method when the jump action is performed
    }

    private void OnEnable()
    {
        inputActions.Enable(); // Enable the Input Actions when the script is enabled
    }

    private void OnDisable()
    {
        inputActions.Disable(); // Disable the Input Actions when the script is disabled
    }

    private void Update()
    {
        HandleMouseLook(); // Handle mouse look every frame
        HandleMovement(); // Handle movement every frame
    }

    private void HandleMouseLook()
    {
        // Get mouse input and scale it by sensitivity and delta time
        float mouseX = lookInput.x * mouseSensitivity * Time.deltaTime;
        float mouseY = lookInput.y * mouseSensitivity * Time.deltaTime;

        // Adjust the vertical rotation and clamp it to prevent over-rotation
        xRotation -= mouseY;
        xRotation = Mathf.Clamp(xRotation, -90f, 90f);

        // Rotate the player horizontally
        transform.Rotate(Vector3.up * mouseX);

        // Rotate the camera vertically
        Camera.main.transform.localRotation = Quaternion.Euler(xRotation, 0f, 0f);
    }

    private void HandleMovement()
    {
        // Check if the player is grounded
        isGrounded = characterController.isGrounded;

        // If grounded and falling, reset the vertical velocity
        if (isGrounded && velocity.y < 0)
        {
            velocity.y = -2f; // Small value to keep the player grounded
        }

        // Calculate movement direction based on input and player orientation
        Vector3 move = transform.right * moveInput.x + transform.forward * moveInput.y;

        // Move the CharacterController
        characterController.Move(move * moveSpeed * Time.deltaTime);

        // Apply gravity to the player
        velocity.y += gravity * Time.deltaTime;

        // Apply the vertical velocity to the CharacterController
        characterController.Move(velocity * Time.deltaTime);
    }

    private void Jump()
    {
        // If the player is grounded, calculate the jump velocity
        if (isGrounded)
        {
            velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity);
        }
    }
}
