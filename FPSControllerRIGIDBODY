using UnityEngine;
using UnityEngine.InputSystem;
public class PlayerController : MonoBehaviour
{
    //made using help from unity built in AI(its ok but no different to what ive done myself just neat n tidy i suppose)
    //a fps controller using a rigidbody

    [Header("Movement Settings")]
    public float moveSpeed = 5f;             //Speed at which the player moves
    public float jumpForce = 5f;             //Force applied when the player jumps

    [Header("Mouse Settings")]
    public float mouseSensitivity = 100f;    //Sensitivity of the mouse for looking around

    [Header("Ground Check")]
    public Transform groundCheck;            //Transform used to check if the player is grounded
    public float groundDistance = 0.4f;      //Radius of the sphere used for ground detection
    public LayerMask groundMask;             //Layer mask to identify what is considered ground

    private Rigidbody rb;                    //Reference to the Rigidbody component
    private PlayerInputActions inputActions; //Reference to the generated Input Actions class
    private Vector2 moveInput;               //Stores movement input from the player
    private Vector2 lookInput;               //Stores look input from the player
    private bool isGrounded;                 //Tracks whether the player is on the ground

    private float xRotation = 0f;            //Tracks the vertical rotation of the camera

    private void Awake()
    {
        rb = GetComponent<Rigidbody>(); // Get the Rigidbody component attached to the player


        //THIS SHIT RIGHT HERE IS STUPID AND OVERLY COMPLICATED LOOKING NO IDEA WTF IS HAPPENING IT HANDLES THE NEW INPUT SYSTEM I THINK FUCK THE NEW INPUT SYSTEM!
        // Initialize the Input Actions
        inputActions = new PlayerInputActions();

        // Subscribe to the Move action
        inputActions.Player.Move.performed += ctx => moveInput = ctx.ReadValue<Vector2>(); // Update moveInput when movement is performed
        inputActions.Player.Move.canceled += ctx => moveInput = Vector2.zero; // Reset moveInput when movement is canceled

        // Subscribe to the Look action
        inputActions.Player.Look.performed += ctx => lookInput = ctx.ReadValue<Vector2>(); // Update lookInput when looking around
        inputActions.Player.Look.canceled += ctx => lookInput = Vector2.zero; // Reset lookInput when looking stops

        // Subscribe to the Jump action
        inputActions.Player.Jump.performed += ctx => Jump(); // Call the Jump method when the jump action is performed
    }

    private void OnEnable()
    {
        inputActions.Enable(); // Enable the Input Actions when the script is enabled
    }

    private void OnDisable()
    {
        inputActions.Disable(); // Disable the Input Actions when the script is disabled
    }

    private void Update()
    {
        HandleMouseLook(); // Handle mouse look every frame
    }

    private void FixedUpdate()
    {
        HandleMovement(); // Handle movement in FixedUpdate for consistent physics updates
    }

    private void HandleMouseLook()
    {
        // Get mouse input and scale it by sensitivity and delta time
        float mouseX = lookInput.x * mouseSensitivity * Time.deltaTime;
        float mouseY = lookInput.y * mouseSensitivity * Time.deltaTime;

        // Adjust the vertical rotation and clamp it to prevent over-rotation
        xRotation -= mouseY;
        xRotation = Mathf.Clamp(xRotation, -90f, 90f);

        // Rotate the player horizontally
        transform.Rotate(Vector3.up * mouseX);

        // Rotate the camera vertically
        Camera.main.transform.localRotation = Quaternion.Euler(xRotation, 0f, 0f);
    }

    private void HandleMovement()
    {
        // Calculate movement direction based on input and player orientation
        Vector3 move = transform.right * moveInput.x + transform.forward * moveInput.y;

        // Set the velocity for movement, preserving the vertical velocity
        Vector3 velocity = move * moveSpeed;
        velocity.y = rb.linearVelocity.y;       //Keep the current vertical velocity (e.g., for jumping)
        rb.linearVelocity = velocity;           //Apply the velocity to the Rigidbody
    }

    private void Jump()
    {
        // Check if the player is grounded using a sphere cast
        isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);

        // If grounded, apply an upward force to make the player jump
        if (isGrounded)
        {
            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
        }
    }
}

